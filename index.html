#!/bin/bash -e
<<\EOF
<!--
  Hey, you decided to check out the source code!
  That is a sign you hopefully know better than to blindly run unknown commands
  from the internet and/or are a curious person. :)

  These are a collection of scripts for Arch Linux.
  This is a work-in-progress and will soon include GPG verification to verify script integrity. See script further below, around line ~215. 
- -->
<!DOCTYPE html>
<html lang='en' class=''>
<head>
<style type="text/css">
a { color: #000000; text-decoration: none}
a:visited { color: #000000; }
</style>
<meta name="viewport" content="initial-scale = 1, maximum-scale=1, user-scalable = 0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<meta name="HandheldFriendly" content="true" />
<meta name="MobileOptimized" content="320" />
<meta charset='UTF-8'>
<title>strong.sh</title>
<meta name="robots" content="noindex">
<style class="page">
    body {
  background: black;
  font-family: 'Varela', sans-serif;
}

.bottomText {
  color: white;
  font-size: 20px;
  position: relative;
  width: 400px;
  margin: 0 auto;
}

.glitch {
  color: white;
  font-size: 50px;
  position: relative;
  width: 400px;
  margin: 0 auto;
}

@keyframes noise-anim {
  0% {
    clip: rect(58px, 9999px, 19px, 0);
  }
  5% {
    clip: rect(33px, 9999px, 58px, 0);
  }
  10% {
    clip: rect(88px, 9999px, 53px, 0);
  }
  15% {
    clip: rect(39px, 9999px, 99px, 0);
  }
  20% {
    clip: rect(30px, 9999px, 100px, 0);
  }
  25% {
    clip: rect(77px, 9999px, 31px, 0);
  }
  30% {
    clip: rect(67px, 9999px, 67px, 0);
  }
  35% {
    clip: rect(15px, 9999px, 20px, 0);
  }
  40% {
    clip: rect(95px, 9999px, 73px, 0);
  }
  45% {
    clip: rect(53px, 9999px, 33px, 0);
  }
  50% {
    clip: rect(47px, 9999px, 41px, 0);
  }
  55% {
    clip: rect(5px, 9999px, 58px, 0);
  }
  60% {
    clip: rect(71px, 9999px, 20px, 0);
  }
  65% {
    clip: rect(45px, 9999px, 33px, 0);
  }
  70% {
    clip: rect(4px, 9999px, 18px, 0);
  }
  75% {
    clip: rect(92px, 9999px, 92px, 0);
  }
  80% {
    clip: rect(47px, 9999px, 96px, 0);
  }
  85% {
    clip: rect(72px, 9999px, 37px, 0);
  }
  90% {
    clip: rect(91px, 9999px, 65px, 0);
  }
  95% {
    clip: rect(69px, 9999px, 92px, 0);
  }
  100% {
    clip: rect(71px, 9999px, 84px, 0);
  }
}
.glitch:after {
  content: attr(data-text);
  position: absolute;
  left: 2px;
  text-shadow: -1px 0 red;
  top: 0;
  color: white;
  background: black;
  overflow: hidden;
  clip: rect(0, 900px, 0, 0);
  animation: noise-anim 2s infinite linear alternate-reverse;
}

@keyframes noise-anim-2 {
  0% {
    clip: rect(14px, 9999px, 65px, 0);
  }
  5% {
    clip: rect(32px, 9999px, 77px, 0);
  }
  10% {
    clip: rect(43px, 9999px, 25px, 0);
  }
  15% {
    clip: rect(98px, 9999px, 84px, 0);
  }
  20% {
    clip: rect(35px, 9999px, 57px, 0);
  }
  25% {
    clip: rect(100px, 9999px, 30px, 0);
  }
  30% {
    clip: rect(1px, 9999px, 41px, 0);
  }
  35% {
    clip: rect(48px, 9999px, 87px, 0);
  }
  40% {
    clip: rect(17px, 9999px, 1px, 0);
  }
  45% {
    clip: rect(43px, 9999px, 81px, 0);
  }
  50% {
    clip: rect(100px, 9999px, 53px, 0);
  }
  55% {
    clip: rect(18px, 9999px, 54px, 0);
  }
  60% {
    clip: rect(75px, 9999px, 45px, 0);
  }
  65% {
    clip: rect(33px, 9999px, 55px, 0);
  }
  70% {
    clip: rect(47px, 9999px, 56px, 0);
  }
  75% {
    clip: rect(29px, 9999px, 46px, 0);
  }
  80% {
    clip: rect(35px, 9999px, 9px, 0);
  }
  85% {
    clip: rect(85px, 9999px, 66px, 0);
  }
  90% {
    clip: rect(5px, 9999px, 10px, 0);
  }
  95% {
    clip: rect(28px, 9999px, 14px, 0);
  }
  100% {
    clip: rect(11px, 9999px, 4px, 0);
  }
}
.glitch:before {
  content: attr(data-text);
  position: absolute;
  left: -2px;
  text-shadow: 1px 0 blue;
  top: 0;
  color: white;
  background: black;
  overflow: hidden;
  clip: rect(0, 900px, 0, 0);
  animation: noise-anim-2 3s infinite linear alternate-reverse;
}

  </style>
</head>

<body>
<div class="glitch" data-text="strong">shell</div>
<div class="bottomText">sh <(curl -s strong.sh)</div>
</body>
</html>
<!--
EOF
#!/bin/bash -e
#    Arch Linux Scripts
#    Copyright (C) 2020  strong.sh
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

clear;
cat << "EOF"
----------------------------------------------------
      _                                       _     
 ___ | |_  _ __   ___   _ __    __ _     ___ | |__  
/ __|| __|| '__| / _ \ | '_ \  / _` |   / __|| '_ \ 
\__ \| |_ | |   | (_) || | | || (_| | _ \__ \| | | |
|___/ \__||_|    \___/ |_| |_| \__, |(_)|___/|_| |_|
                               |___/              

           = Arch Linux Scripts - v1.1 =
----------------------------------------------------

EOF




# Main Menu
echo "Enter choice [ 1 - 4]"
echo "  1) Barebones installer (to be used from live archiso)" # Starting on line ~258
echo "  2) Post-install configuration" # Starting on line ~539
echo "  3) Hardening script (experimental)" # Starting on line ~1225
echo "  4) Exit\n" 

read n
case $n in
  1) echo "Starting Automated Barebones Installer..\n"

sleep 1
clear;
# Greeting.
echo "Hello. This will guide you through the installation of Arch Linux (currently only with support for GRUB) directly after initial boot from the archiso. To use this script enter 'y' for yes and 'n' for no. Any other option will be described.\n"
sleep 1

# Shutdown.
read -r -p "Do you want to start the installation now? Entering 'n' will exit the script. (y/n) " start
if [ "${start}" = "n" ]; then
  exit 0
fi

setup_wifi() {
  ## Setup WiFi.
  read -r -p "Do you want to use WiFi? (y/n) " wifi
  if [ "${wifi}" = "y" ]; then
    # Details needed to create connection.
    read -r -p "What is it called? " wifi_name
    read -r -p "What is the password? " wifi_password

    # Show list of network interfaces.
    ip a
    read -r -p "What is your Wifi network interface? " wifi_interface

    # Copy netctl example profile.
    cp /etc/netctl/examples/wireless-wpa /etc/netctl/"${wifi_name}"

    # Insert needed details.
    sed -i "s/MyNetwork/${wifi_name}/" /etc/netctl/"${wifi_name}"
    sed -i "s/WirelessKey/${wifi_password}/" /etc/netctl/"${wifi_name}"
    sed -i "s/wlan0/${wifi_interface}/" /etc/netctl/"${wifi_name}"

    # Start the WiFi connection.
    netctl start "${wifi_name}"
  fi
}

use_reflector() {
  # List supported countries.
  echo "Supported country codes:"
  echo ""
  reflector --list-countries | awk '{print $(NF-1)}' | xargs | sed -e 's/ /, /g'
  echo ""

  read -r -p "What country do you want your mirrors to be in? Enter the country code. " mirror_country
  mirror_warning="0"

  # Makes reflector run again if the user enters an invalid code.
  for i in $(reflector --list-countries | awk '{print $(NF-1)}')
  do
    if [ "${mirror_country}" = "${i}" ]; then
      mirror_warning="1"
      break
    fi
  done

  if ! [ "${mirror_warning}" = "1" ]; then
    echo "ERROR: That is not a supported country."
    echo ""
    use_reflector
  fi
}

update_mirrorlist() {
  ## Update mirrorlist.
  # Move the mirrorlist back if a backup has already been made.
  if ! [ -f /etc/pacman.d/mirrorlist ] && [ -f /etc/pacman.d/mirrorlist.backup ]; then
    mv /etc/pacman.d/mirrorlist.backup /etc/pacman.d/mirrorlist
  fi

  # Install reflector.
  if ! pacman -Qq reflector &>/dev/null; then
    pacman -Sy -q --noconfirm reflector >/dev/null
  fi

  # Move current mirrorlist for use as a backup.
  mv /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup

  # Get the correct country code for updating the mirrorlist.
  use_reflector

  # Use reflector to update mirrors.
  reflector --country "${mirror_country}" --save /etc/pacman.d/mirrorlist

  # Update mirrorlist.
  pacman -Syyy
}

partition_drive() {
  # Show the user their drives.
  fdisk -l
  sleep 2

  # Ask what device to use and the size of the root partition.
  read -r -p "Which drive do you want to partition? " device
  read -r -p "How big do you want the root partition? Use 'GiB' or 'MiB' e.g 200GiB. Enter '100%' if you want it to fill up the rest of the drive. " rootsize

  # Set default uefi value.
  uefi=n

  # Detect if it was booted using UEFI.
  if [ -d /sys/firmware/efi/ ]; then
    uefi=y
  fi

  # UEFI partitioning.
  if [ "${uefi}" = "y" ]; then
    # Create a new GPT partition layout.
    parted -s "${device}" mklabel gpt &>/dev/null

    # Create a 551MiB FAT32 boot partition.
    parted "${device}" mkpart primary fat32 1MiB 551MiB &>/dev/null
    parted "${device}" set 1 esp on &>/dev/null

    # Format the boot partition.
    mkfs.fat -F32 "${device}"1 >/dev/null

    # Create a EXT4 root partition.
    parted "${device}" mkpart primary ext4 551MiB "${rootsize}" &>/dev/null

    # Format the root partition.
    mkfs.ext4 "${device}"2 >/dev/null

    # Mount the root partition as /mnt.
    mount "${device}"2 /mnt

    # For home partition.
    home_part="3"
  else
    # BIOS partitioning.
    # Create a new DOS partition layout.
    parted -s "${device}" mklabel msdos &>/dev/null

    # Create a EXT4 root partition.
    parted "${device}" mkpart primary ext4 1MiB "${rootsize}" &>/dev/null

    # Allow it to be booted into.
    parted "${device}" set 1 boot on &>/dev/null

    # Format the partition.
    yes | mkfs.ext4 "${device}"1 >/dev/null

    # Mount the partition as /mnt
    mount "${device}"1 /mnt

    # For home partition.
    home_part="2"
  fi

  # Create a home partition.
  read -r -p "Do you want a seperate home partition? (y/n) " wanthome
  if [ "${wanthome}" = "y" ]; then
    read -r -p "How big do you want the home partition? Use 'GiB' or 'MiB' e.g 200GiB. Enter '100%' if you want it to fill up the rest of the drive. " homesize

    # Create a EXT4 home partition.
    parted "${device}" mkpart primary ext4 "${rootsize}" "${homesize}"

    # Format the home partition.
    mkfs.ext4 "${device}""${home_part}"

    # Create a home directory and mount the drive.
    mkdir /mnt/home
    mount "${device}""${home_part}" /mnt/home
  fi
}

installation() {
  # Install base packages with pacstrap.
  pacstrap /mnt base

  # Generate /etc/fstab.
  genfstab -U -p /mnt >> /mnt/etc/fstab

  # Copy mirrorlist.
  mv /mnt/etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist.backup
  cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist

  # Create the script to be run in the chroot.
  cat <<\EOF > /mnt/root/archinstall-part2.sh
#!/bin/bash

# Update mirrorlist.
pacman -Syyy >/dev/null

# Install packages needed for GRUB. linux-headers isn't really needed but will help with other things.
pacman -S --noconfirm -q grub efibootmgr dosfstools mtools linux-headers

# Generate initcpio.
mkinitcpio -p linux

get_locale() {
  # List supported locales.
  echo "Supported locales:"
  echo ""
  awk '{print $1}' /etc/locale.gen | sed -e's/#//g' | sed -e 's/@.*//g' | sed -e 's/\..*//g' | awk '!x[$0]++' | xargs | sed -e 's/ /, /g'
  echo ""

  read -r -p "Which locale do you want? " locale
  locale_warning="0"

  # Run again if the user enters an invalid locale.
  for i in $(awk '{print $1}' /etc/locale.gen | sed -e's/#//g' | sed -e 's/@.*//g' | sed -e 's/\..*//g' | awk '!x[$0]++')
  do
    if [ "${locale}" = "${i}" ]; then
      locale_warning="1"
      break
    fi
  done

  if ! [ "${locale_warning}" = "1" ]; then
    echo "ERROR: That is not a supported locale."
    echo ""
    get_locale
  fi
}

# Get the correct locale.
get_locale

# Generate locale.
sed -i "s/#${locale}.UTF-8 UTF-8/${locale}.UTF-8 UTF-8/" /etc/locale.gen
sed -i "s/#${locale} UTF-8/${locale} UTF-8/" /etc/locale.gen
locale-gen

# Set locale.
localectl set-locale LANG=${locale}.UTF-8

# Install GRUB.
if [ "${uefi}" = "y" ]; then
  # Install GRUB for UEFI.
  mkdir /boot/EFI
  mount "${device}"1 /boot/EFI
  grub-install --target=x86_64-efi --bootloader-id=grub_uefi --recheck
elif [ "${uefi}" = "n" ]; then
  # Install GRUB for BIOS.
  grub-install --target=i386-pc --recheck "${device}"
fi

# Set GRUB locale.
cp /usr/share/locale/en\@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo

# Generate GRUB configuration file.
grub-mkconfig -o /boot/grub/grub.cfg

# Exit the chroot.
exit
EOF

  # Add needed variables to script.
  sed -i "3s|^|uefi=${uefi}\n|" /mnt/root/archinstall-part2.sh
  sed -i "3s|^|device=${device}\n|" /mnt/root/archinstall-part2.sh

  # Make the script executable.
  chmod +x /mnt/root/archinstall-part2.sh

  # Chroot into system and run the script.
  arch-chroot /mnt /root/archinstall-part2.sh
}

last_steps() {
  # Unmount all partitions.
  umount -R /mnt

  # Reboot.
  read -r -p "Do you want to reboot? (y/n) " reboot
  if [ "${reboot}" = "y" ]; then
    reboot
  fi
}

setup_wifi
update_mirrorlist
partition_drive
installation
last_steps

exit
;;

  2) echo "Starting Post-install Configuration..\n";

sleep 1
clear;

greeting() {
  # Greeting.
  echo "Hello. This will guide you through the post-install of Arch Linux."
  read -r -p "Do you want to start this now? Entering 'n' will exit the script. " start
  if [ "${start}" = "n" ]; then
    exit 0
  fi
}

setup_ethernet() {
  # Setup ethernet.
  read -r -p "Do you want to use ethernet? (y/n) " ethernet
  if [ "${ethernet}" = "y" ]; then
    # Enables systemd dhcpcd service.
    systemctl enable dhcpcd
  fi
}

setup_wifi() {
  # Setup WiFi.
  read -r -p "Do you want to use WiFi? (y/n) " wifi
  if [ "${wifi}" = "y" ]; then
    # Details needed to create connection.
    read -r -p "What is it called? " wifi_name
    read -r -p "What is the password? " wifi_password
    read -r -p "What is your wifi interface? " wifi_interface

    # Copy netctl example profile.
    cp /etc/netctl/examples/wireless-wpa /etc/netctl/"${wifi_name}"

    # Insert needed details.
    sed -i "s/MyNetwork/${wifi_name}/" /etc/netctl/"${wifi_name}"  #(Change interface, ESSID, Key [Password])
    sed -i "s/WirelessKey/${wifi_password}/" /etc/netctl/"${wifi_name}"
    sed -i "s/wlan0/${wifi_interface}/" /etc/netctl/"${wifi_name}"

    # Start the WiFi connection.
    netctl start "${wifi_name}"
  fi
}

get_locale() {
  # List supported locales.
  echo "Supported locales:"
  echo ""
  awk '{print $1}' /etc/locale.gen | sed -e's/#//g' | sed -e 's/@.*//g' | sed -e 's/\..*//g' | awk '!x[$0]++' | xargs | sed -e 's/ /, /g'
  echo ""

  read -r -p "Which locale do you want? " locale
  locale_warning="0"

  # Run again if the user enters an invalid locale.
  for i in $(awk '{print $1}' /etc/locale.gen | sed -e's/#//g' | sed -e 's/@.*//g' | sed -e 's/\..*//g' | awk '!x[$0]++')
  do
    if [ "${locale}" = "${i}" ]; then
      locale_warning="1"
      break
    fi
  done

  if ! [ "${locale_warning}" = "1" ]; then
    echo "ERROR: That is not a supported locale."
    echo ""
    get_locale
  fi
}

get_keymap() {
  # List supported keymaps.
  echo "Supported keymaps:"
  echo ""
  find /usr/share/kbd/keymaps/ -type f | awk -F"/" '{print $NF}' | sed -e 's/.map.gz//g' | xargs | sed -e 's/ /, /g'
  echo ""

  read -r -p "Which keymap do you want? " keymap
  keymap_warning="0"

  # Run again if the user enters an invalid keymap.
  for i in $(find /usr/share/kbd/keymaps/ -type f | awk -F"/" '{print $NF}' | sed -e 's/.map.gz//g')
  do
    if [ "${keymap}" = "${i}" ]; then
      keymap_warning="1"
      break
    fi
  done

  if ! [ "${keymap_warning}" = "1" ]; then
    echo "ERROR: That is not a supported keymap."
    echo ""
    get_keymap
  fi
}

set_locale_and_keymap() {
  # Set locale.
  get_locale
  localectl set-locale LANG="${locale}.UTF-8"

  # Set keymap.
  get_keymap
  localectl set-keymap --no-convert "${keymap}"
}

get_kernel() {
  echo ""

  # Say if already installed.
  if pacman -Qq linux-hardened &>/dev/null; then
    echo "1) linux-hardened - ALREADY INSTALLED"
  else
    echo "1) linux-hardened"
  fi

  if pacman -Qq linux-lts &>/dev/null; then
    echo "2) linux-lts - ALREADY INSTALLED"
  else
    echo "2) linux-lts"
  fi
  echo "3) None"
  echo ""

  read -r -p "Which kernel do you want to install? " which_kernel

  # Run again if the user enters an invalid kernel.
  if ! [ "${which_kernel}" = "1" ] && ! [ "${which_kernel}" = "2" ] && ! [ "${which_kernel}" = "3" ]; then
    echo "ERROR: That is not a supported kernel."
    echo ""
    get_kernel
  fi
}

install_extra_kernels() {
  # Install extra kernels.
  if ! [ "${another_kernel}" = "y" ]; then
    read -r -p "Do you want to install an extra kernel? (y/n) " install_kernels
  fi

  if [ "${install_kernels}" = "y" ]; then
    # Select which kernel to install.
    get_kernel
    if [ "${which_kernel}" = "1" ]; then
      # Install linux-hardened.
      pacman -S --noconfirm -q linux-hardened linux-hardened-headers

      # Generate initcpio.
      mkinitcpio -p linux-hardened
    fi

    if [ "${which_kernel}" = "2" ]; then
      # Install linux-lts.
      pacman -S --noconfirm -q linux-lts linux-lts-headers

      # Generate initcpio.
      mkinitcpio -p linux-lts
    fi

    if ! [ "${which_kernel}" = "3" ]; then
      # Generate new GRUB configuration.
      grub-mkconfig -o /boot/grub/grub.cfg

      # Install another kernel.
      read -r -p "Install another kernel? (y/n) " another_kernel
      if [ "${another_kernel}" = "y" ]; then
        install_extra_kernels
      fi
    fi
  fi
}

set_root_password() {
  # Set root password.
  read -r -p "Do you want to set a root password? (y/n) " rootpass
  if [ "${rootpass}" = "y" ]; then
    passwd
  fi
}

create_swap() {
  # Create swap file.
  read -r -p "Would you like a swap file? (y/n) " swapfile
  if [ "${swapfile}" = "y" ]; then
    read -r -p "How big do you want it? Enter 'G' or 'M' e.g '2G' " swapsize
    # Create /swapfile.
    fallocate -l "${swapsize}" /swapfile

    # Set the swapfile's mode to 600/
    chmod 600 /swapfile

    # Use /swapfile as swap.
    mkswap /swapfile

    # Add /swapfile to fstab.
    echo '/swapfile none swap sw 0 0' | tee -a /etc/fstab >/dev/null
  fi
}

install_packages() {
  # Install networkmanager.
  read -r -p "Do you want to install networkmanager? (y/n) " netmn
  if [ "${netmn}" = "y" ]; then
    pacman -S --noconfirm -q networkmanager network-manager-applet
  fi

  # Install tools needed for WiFi.
  read -r -p "Do you want to install tools needed for WiFi? (y/n) " install_wifi_tools
  if [ "${install_wifi_tools}" = "y" ]; then
    pacman -S --noconfirm -q wireless_tools wpa_supplicant
  fi

  # Install xorg-server and xorg-xinit.
  read -r -p "Do you want to install xorg-server and xorg-xinit? (y/n) " install_xorg
  if [ "${install_xorg}" = "y" ]; then
    (echo   ) | pacman -S --noconfirm -q xorg-server xorg-xinit mesa
  fi

  # Add multilib repo.
  read -r -p "Do you want to add the multilib repo to pacman.conf? This allows you to run 32-bit programs. (y/n) " multilib
  if [ "${multilib}" = "y" ]; then
    sed -i "/\[multilib\]/,/Include/"'s/^#//' /etc/pacman.conf

    # Updates mirrorlists.
    pacman -Syyy
  fi

  # Add touchpad support.
  read -r -p "Do you want touchpad support? (y/n) " touchpad
  if [ "${touchpad}" = "y" ]; then
    pacman -S --noconfirm -q xf86-input-libinput
  fi

  # Install sudo.
  read -r -p "Do you want to install and configure sudo? (y/n) " sudo
  if [ "${sudo}" = "y" ]; then
    # Installs sudo.
    pacman -S --noconfirm -q sudo

    # Allows members of the wheel group to use sudo.
    sed -i 's/# %wheel ALL=(ALL) ALL/%wheel ALL=(ALL) ALL/' /etc/sudoers
  fi
}

get_drivers() {
  echo ""

  # Say if already installed.
  if pacman -Qq xf86-video-intel &>/dev/null; then
    echo "1) Intel drivers - ALREADY INSTALLED"
  else
    echo "1) Intel drivers"
  fi

  if pacman -Qq virtualbox-guest-dkms &>/dev/null; then
    echo "2) Virtualbox drivers - ALREADY INSTALLED"
  elif pacman -Qq virtualbox-guest-modules-arch &>/dev/null; then
    echo "2) Virtualbox drivers - ALREADY INSTALLED"
  else
    echo "2) Virtualbox drivers"
  fi
  echo "3) None"
  echo ""

  read -r -p "Which driver do you want to install? " which_driver

  # Run again if the user enters an invalid option.
  if ! [ "${which_driver}" = "1" ] && ! [ "${which_driver}" = "2" ] && ! [ "${which_driver}" = "3" ]; then
    echo "ERROR: That is not a supported option."
    echo ""
    get_drivers
  fi
}

install_drivers() {
  # Install Intel or virtualbox drivers.
  if ! [ "${another_driver}" = "y" ]; then
    read -r -p "Do you want to install extra drivers? (y/n) " install_extra_drivers
  fi

  if [ "${install_extra_drivers}" = "y" ]; then
    get_drivers

    # Install Intel drivers.
    if [ "${which_driver}" = "1" ]; then
      pacman -S --noconfirm -q xf86-video-intel

      # Install multilib Intel drivers.
      if [ "${multilib}" = "y" ]; then
        # Install multilib Intel drivers.
        pacman -S --noconfirm -q lib32-intel-dri lib32-mesa lib32-libgl
      fi
    fi

    # Install Virtualbox drivers.
    if [ "${which_driver}" = "2" ]; then
      read -r -p "Are you using the default kernel? (y/n) " default_kernel
      read -r -p "Do you want X11 support? (y/n) " xsupport

      if [ "${default_kernel}" = "y" ]; then
        if [ "${xsupport}" = "y" ]; then
          # Install default kernel virtualbox drivers with X11 support.
          (echo 2 ) | pacman -S --noconfirm -q virtualbox-guest-utils
        elif [ "${xsupport}" = "n" ]; then
          # Install default kernel virtualbox drivers without X11 support.
          (echo 2 ) | pacman -S --noconfirm -q virtualbox-guest-utils-nox
        fi
      elif [ "${default_kernel}" = "n" ]; then
        if [ "${xsupport}" = "y" ]; then
          # Install non-default kernel virtualbox drivers with X11 support.
          (echo 1 ) | pacman -S --noconfirm -q virtualbox-guest-utils
        elif [ "${xsupport}" = "n" ]; then
          # Install non-default kernel virtualbox drivers without X11 support.
          (echo 1 ) | pacman -S --noconfirm -q virtualbox-guest-utils-nox
        fi
      fi
    fi

    if ! [ "${which_driver}" = "3" ]; then
      # Install another driver.
      read -r -p "Install another driver? (y/n) " another_driver
      if [ "${another_driver}" = "y" ]; then
        install_drivers
      fi
    fi
  fi
}

configure_system() {
  # Add user.
  read -r -p "Do you want to add a user? (y/n) " user
  if [ "${user}" = "y" ]; then
    read -r -p "What do you want to name it? " username

    # Create new user in the wheel group with a home directory and set its default shell to bash.
    useradd -m -G wheel -s /bin/bash "${username}"
    read -r -p "Do you want to set a password for your user? (y/n) " passwduser
    if [ "${passwduser}" = "y" ]; then
      # Change the user's password.
      passwd "${username}"
    fi
  fi

  # Change the hostname.
  read -r -p "Do you want to change the hostname? (y/n) " change_hostname
  if [ "${change_hostname}" = "y" ]; then
    read -r -p "What is the new hostname? " new_hostname

    # Set the hostname.
    hostnamectl set-hostname "${new_hostname}"
  fi
}

get_desktop() {
  echo ""

  # Say if already installed.
  if pacman -Qq xfce4-session &>/dev/null; then
    echo "1) XFCE - ALREADY INSTALLED"
  else
    echo "1) XFCE"
  fi

  if pacman -Qq gnome-session &>/dev/null; then
    echo "2) GNOME - ALREADY INSTALLED"
  else
    echo "2) GNOME"
  fi

  if pacman -Qq plasma-desktop &>/dev/null; then
    echo "3) KDE - ALREADY INSTALLED"
  else
    echo "3) KDE"
  fi

  if pacman -Qq mate-desktop &>/dev/null; then
    echo "4) MATE - ALREADY INSTALLED"
  else
    echo "4) MATE"
  fi

  echo "5) None"
  echo ""

  read -r -p "Which desktop environment do you want to install? " which_desktop_environment

  # Run again if the user enters an invalid option.
  if ! [ "${which_desktop_environment}" = "1" ] && ! [ "${which_desktop_environment}" = "2" ] && ! [ "${which_desktop_environment}" = "3" ] && ! [ "${which_desktop_environment}" = "4" ] && ! [ "${which_desktop_environment}" = "5" ]; then
    echo "ERROR: That is not a supported desktop environment."
    echo ""
    get_desktop
  fi
}


install_desktop_environment() {
  # Install a DE.
  if ! [ "${another_desktop_environment}" = "y" ]; then
    read -r -p "Do you want to install a desktop environment? (y/n) " install_de
  fi

  if [ "${install_de}" = "y" ] ; then
    # Install xorg-server and xorg-xinit. These are needed to start the DEs.
    if ! [ "${install_xorg}" = "y" ]; then
      (echo   ) | pacman -S --noconfirm -q xorg-server xorg-xinit mesa
    fi

    get_desktop

    if ! [ "${another_desktop_environment}" = "y" ]; then
      read -r -p "Do you want to create a xinitrc for your desktop environment? (This is needed to start it with 'startx') (y/n) " create_xinitrc
      if [ "${create_xinitrc}" = "y" ]; then
        if [ "${user}" = "y" ]; then
          # Path to xinitrc.
          xinitrc_file="/home/${username}/.xinitrc"

          # Copy xinitrc to user's home directory.
          cp /etc/X11/xinit/xinitrc "${xinitrc_file}"
        elif [ "${user}" = "n" ]; then
          # Path to xinitrc.
          xinitrc_file="/etc/X11/xinit/xinitrc"

          # Create a backup of the xinitrc.
         cp /etc/X11/xinit/xinitrc /etc/X11/xinit/xinitrc.backup
        fi

        # Removes unnessecary lines from xinitrc.
        for i in {1..5}
        do
          sed -i '51d' ${xinitrc_file}
        done
      fi
    fi

    # Installs XFCE.
    if [ "${which_desktop_environment}" = "1" ] ; then
      pacman -S --noconfirm -q xfce4

      # Edit the xinitrc for XFCE.
      if [ "${create_xinitrc}" = "y" ]; then
        echo "exec startxfce4" | tee -a "${xinitrc_file}" >/dev/null
      fi
    fi

    # Installs GNOME.
    if [ "${which_desktop_environment}" = "2" ] ; then
      pacman -S --noconfirm -q gnome

      # Edit the xinitrc for GNOME.
      if [ "${create_xinitrc}" = "y" ]; then
        echo "export GDK_BACKEND=x11" | tee -a "${xinitrc_file}" >/dev/null
        echo "exec gnome-session" | tee -a "${xinitrc_file}" >/dev/null
      fi
    fi

    # Installs KDE.
    if [ "${which_desktop_environment}" = "3" ] ; then
      pacman -S --noconfirm -q plasma-desktop

      # Edit the xinitrc for KDE.
      if [ "${create_xinitrc}" = "y" ]; then
        echo "exec startkde" | tee -a "${xinitrc_file}" >/dev/null
      fi
    fi

    # Installs MATE.
    if [ "${which_desktop_environment}" = "4" ] ; then
      sudo pacman -S --noconfirm -q mate

      # Edit the xinitrc for MATE.
      if [ "${create_xinitrc}" = "y" ]; then
        echo "exec mate-session" | tee -a ${xinitrc_file} >/dev/null
      fi
    fi

    if ! [ "${which_desktop_environment}" = "5" ]; then
      # Install another driver.
      read -r -p "Install another desktop environment? (y/n) " another_desktop_environment
      if [ "${another_desktop_environment}" = "y" ]; then
        install_desktop_environment
      fi
    fi
  fi
}

get_de_extras() {
  echo ""

  # Say if already installed.
  if pacman -Qq xfce4-goodies &>/dev/null; then
    echo "1) xfce4-goodies - ALREADY INSTALLED"
  else
    echo "1) xfce4-goodies"
  fi

  if pacman -Qq gnome-session &>/dev/null; then
    echo "2) gnome-extra - ALREADY INSTALLED"
  else
    echo "2) gnome-extra"
  fi

  if pacman -Qq plasma-desktop &>/dev/null; then
    echo "3) kde-applications - ALREADY INSTALLED"
  else
    echo "3) kde-applications"
  fi

  if pacman -Qq mate-desktop &>/dev/null; then
    echo "4) mate-extra - ALREADY INSTALLED"
  else
    echo "4) mate-extra"
  fi

  echo "5) None"
  echo ""

  read -r -p "Which extra desktop environment programs do you want to install? " which_de_extras

  # Run again if the user enters an invalid option.
  if ! [ "${which_de_extras}" = "1" ] && ! [ "${which_de_extras}" = "2" ] && ! [ "${which_de_extras}" = "3" ] && ! [ "${which_de_extras}" = "4" ] && ! [ "${which_de_extras}" = "5" ]; then
    echo "ERROR: That is not a supported option."
    echo ""
    get_de_extras
  fi
}

install_extra_de_programs() {
  if ! [ "${more_de_programs}" = "y" ]; then
    read -r -p "Do you want to install extra desktop environment programs? (y/n) " install_de_extras
  fi

  if [ "${install_de_extras}" = "y" ]; then
    get_de_extras

    # Installs extra XFCE programs.
    if [ "${which_de_extras}" = "1" ] ; then
      pacman -S --noconfirm -q xfce4-goodies
    fi

    # Installs extra GNOME programs.
    if [ "${which_de_extras}" = "2" ] ; then
      pacman -S --noconfirm -q gnome-extra
    fi

    # Installs extra KDE programs.
    if [ "${which_de_extras}" = "3" ] ; then
      sudo pacman -S --noconfirm -q kde-applications
    fi

    # Installs extra MATE programs.
    if [ "${mate-which_de_extras}" = "4" ] ; then
      sudo pacman -S --noconfirm -q mate-extra
    fi

    if ! [ "${which_desktop_environment}" = "5" ]; then
      # Install more desktop environment programs..
      read -r -p "Install more extra desktop environment programs? (y/n) " more_de_programs
      if [ "${more_de_programs}" = "y" ]; then
        install_extra_de_programs
      fi
    fi
  fi
}

configure_x11() {
    # Auto startx at login.
    if [ "${create_xinitrc}" = "y" ]; then
      read -r -p "Do you want to automatically start your DE at login? (y/n) " autostartx

      # Use user's bashrc if a user was created.
      if [ "${user}" = "y" ]; then
        # Create bashrc if not already.
        if ! [ -f "/home/${username}/.bashrc" ]; then
          cp /etc/skel/.bashrc "/home/${username}/.bashrc"
          chown "${username}" "/home/${username}/.bashrc"
          chmod 644 "/home/${username}/.bashrc"
        fi

        # Set the variable to the user's bashrc.
        bashrc_file="/home/${username}/.bashrc"
      else
        bashrc_file="/etc/bash.bashrc"
      fi

      if [ "${autostartx}" = "y" ]; then
        echo '''
if [[ ! $DISPLAY && $XDG_VTNR -eq 1 ]]; then
  exec startx
fi ''' | tee -a "${bashrc_file}" >/dev/null
      fi
  fi
}

install_extra_programs() {
  # Install Firefox.
  read -r -p "Do you want to install Firefox? (y/n) " firefox
  if [ "${firefox}" = "y" ] ; then
    pacman -S --noconfirm -q firefox >/dev/null
  fi

  # Install ProtonVPN.
  read -r -p "Do you want to install the ProtonVPN client? (y/n)  " pvpn
  if [ "${pvpn}" = "y" ] ; then
    # Install needed packages.
    pacman -S --noconfirm -q openvpn python dialog wget

    # Download ProtonVPN client.
    wget -O --https-only protonvpn-cli.sh https://raw.githubusercontent.com/ProtonVPN/protonvpn-cli/master/protonvpn-cli.sh

    # Make it executable.
    chmod +x protonvpn-cli.sh

    # Install it.
    ./protonvpn-cli.sh --install

    # Initialize profile.
    pvpn -init
    echo "Run 'pvpn -f' to connect to the fastest server or run 'pvpn -c' to choose which server to connect to."
  fi

  # Install yay.
  read -r -p "Do you want to install yay (an AUR helper)? (y/n) " install_yay
  if [ "${install_yay}" = "y" ]; then
    # Install git.
    pacman -S --noconfirm -q git >/dev/null

    # Install base-devel.
    pacman -S --noconfirm -q base-devel

    # Create a user for installing yay as yay cannot be run as root.
    useradd -m --home-dir /home/yay -s /bin/bash yay

    # Allow the yay user to run sudo without a password (needed for using makepkg without entering a password).
    echo "yay ALL=(ALL) NOPASSWD: ALL" | tee -a /etc/sudoers >/dev/null

    # Clone yay.
    git clone https://aur.archlinux.org/yay.git /home/yay/yay
    chown yay -R /home/yay
    continue_yay_installation="y"

    # Verify PKGBUILD.
    read -r -p "Do you want to verify the yay PKGBUILD? (y/n) " verify_yay_pkgbuild
    if [ "${verify_yay_pkgbuild}" = "y" ]; then
      less /home/yay/yay/PKGBUILD

      # Allow the user to stop yay from being installed.
      read -r -p "Continue installing yay? (y/n) " continue_yay_installation
    fi

    if [ "${continue_yay_installation}" = "y" ]; then
      # Install yay as the yay user.
      sudo -u yay sh -c "cd /home/yay/yay && makepkg --noconfirm -si"
    else
      echo "Yay has not been installed."
    fi

    # Delete yay user.
    userdel -rf yay &>/dev/null
    sed -i 's/yay ALL=(ALL) NOPASSWD: ALL//' /etc/sudoers
  fi
}

greeting
setup_ethernet
setup_wifi
set_locale_and_keymap
install_extra_kernels
set_root_password
create_swap
install_packages
install_drivers
configure_system
install_desktop_environment
install_extra_de_programs
configure_x11
install_extra_programs

# Reboot.
read -r -p "Reboot now? (y/n) " reboot
if [ "${reboot}" = "y" ] ; then
  reboot
fi

exit;
;;
  3) echo "Starting Arch Hardening Script..\n";

sleep 1
clear;

# Please see https://theprivacyguide1.github.io/linux_hardening_guide

while test $# -gt 0; do
        case "$1" in
                --disable-checks)
                                # Disable script_checks.
                                disable_checks=1
                                exit 1
                                ;;
                *)
                                echo "'${*}' is not a correct flag."
                                exit 1
                                ;;

        esac
done

create_grub_directory() {
  # Create /etc/default/grub.d if it doesn't already exist.
  if ! [ -d /etc/default/grub.d ]; then
    mkdir -m 755 /etc/default/grub.d

    # Make /etc/default/grub source grub.d.
    # shellcheck disable=SC2016
    echo '
for i in /etc/default/grub.d/*.cfg ; do
if [ -e "${i}" ]; then
  . "${i}"
fi
done
' >> /etc/default/grub
  fi
}

syslinux_append() {
  new_boot_parameters="$1"

  # Get list of current boot parameters.
  syslinux_parameters=$(grep -v "Fallback" /boot/syslinux/syslinux.cfg | grep -C 2 "MENU LABEL Arch Linux" | grep "APPEND")

  # Add new boot parameters.
  sed -i "s|${syslinux_parameters}|${syslinux_parameters} ${new_boot_parameters}|" /boot/syslinux/syslinux.cfg
}

script_checks() {
  if ! [ "${disable_checks}" = "1" ]; then
    # Check for root
    if [[ "$(id -u)" -ne 0 ]]; then
      echo "This script needs to be run as root."
      exit 1
    fi

    # Check if on Arch Linux or a derivative.
    if grep "Arch Linux" /etc/os-release &>/dev/null; then
      true
    elif grep "Manjaro Linux" /etc/os-release &>/dev/null; then
      true
    else
      echo "This script can only be used on Arch Linux or Manjaro."
      exit 1
    fi

    # Check which bootloader is being used.
    if [ -d /boot/grub ]; then
      use_grub="y"
      # Create /etc/default/grub.d if it doesn't already exist.
      create_grub_directory
    elif [ -d /boot/syslinux ]; then
      use_syslinux="y"

      if ! grep "MENU LABEL Arch Linux" /boot/syslinux/syslinux.cfg >/dev/null; then
        echo "The 'Arch Linux' menu label is missing from your Syslinux configuration file."
        exit 1
      fi
    else
      echo "This script can only be used with GRUB or syslinux."
      exit 1
    fi

    # Check if using systemd.
    # shellcheck disable=SC2009
    if ! ps -p 1 | grep systemd &>/dev/null; then
      echo "This script can only be used with systemd."
      exit 1
    fi
  fi
}

sysctl_hardening() {
  ## Sysctl
  read -r -p "Harden the kernel with sysctl? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#sysctl) (y/n) " sysctl
  if [ "${sysctl}" = "y" ]; then
    # Hide kernel symbols in /proc/kallsyms.
    read -r -p "Hide kernel symbols in /proc/kallsyms? (y/n) " kallsyms
    if [ "${kallsyms}" = "y" ]; then
      echo "kernel.kptr_restrict=2" > /etc/sysctl.d/kptr_restrict.conf
    fi

    # Restrict dmesg to root.
    read -r -p "Restrict dmesg to root only? (y/n) " dmesg
    if [ "${dmesg}" = "y" ]; then
      echo "kernel.dmesg_restrict=1" > /etc/sysctl.d/dmesg_restrict.conf
    fi

    # Harden BPF JIT compiler.
    read -r -p "Harden the BPF JIT compiler? (y/n) " jit
    if [ "${jit}" = "y" ]; then
      echo "kernel.unprivileged_bpf_disabled=1
net.core.bpf_jit_harden=2" > /etc/sysctl.d/harden_bpf.conf
    fi

    # Restrict ptrace to root.
    read -r -p "Restrict ptrace to root only? (y/n) " ptrace
    if [ "${ptrace}" = "y" ]; then
      echo "kernel.yama.ptrace_scope=2" > /etc/sysctl.d/ptrace_scope.conf
    fi

    # Disable kexec.
    read -r -p "Disable kexec? (y/n) " kexec
    if [ "${kexec}" = "y" ]; then
      echo "kernel.kexec_load_disabled=1" > /etc/sysctl.d/kexec.conf
    fi

    # Harden the TCP/IP stack.
    read -r -p "Harden the TCP/IP stack? (y/n) " tcp_ip_stack_hardening
    if [ "${tcp_ip_stack_hardening}" = "y" ]; then
      # Enable TCP syncookies.
      read -r -p "Enable TCP syncookies? (y/n) " tcp_syncookies
      if [ "${tcp_syncookies}" = "y" ]; then
        echo "net.ipv4.tcp_syncookies=1" >> /etc/sysctl.d/tcp_hardening.conf
      fi

      # Protect against time-wait assassination.
      read -r -p "Protect against time-wait assassination? (y/n) " tcp_timewait_assassination
      if [ "${tcp_timewait_assassination}" = "y" ]; then
        echo "net.ipv4.tcp_rfc1337=1" >> /etc/sysctl.d/tcp_hardening.conf
      fi

      # Enable reverse path filtering.
      read -r -p "Enable reverse path filtering (rp_filter)? (y/n) " enable_rp_filter
      if [ "${enable_rp_filter}" = "y" ]; then
         echo "net.ipv4.conf.default.rp_filter=1
net.ipv4.conf.all.rp_filter=1" >> /etc/sysctl.d/tcp_hardening.conf
      fi

      # Disable ICMP redirect acceptance.
      read -r -p "Disable ICMP redirect acceptance? (y/n) " disable_icmp_redirect_acceptance
      if [ "${disable_icmp_redirect_acceptance}" = "y" ]; then
        echo "net.ipv4.conf.all.accept_redirects=0
net.ipv4.conf.default.accept_redirects=0
net.ipv4.conf.all.secure_redirects=0
net.ipv4.conf.default.secure_redirects=0
net.ipv6.conf.all.accept_redirects=0
net.ipv6.conf.default.accept_redirects=0" >> /etc/sysctl.d/tcp_hardening.conf
      fi

      # Disable ICMP redirect sending.
      read -r -p "Disable ICMP redirect sending? (y/n) " disable_icmp_redirect_sending
      if [ "${disable_icmp_redirect_sending}" = "y" ]; then
        echo "net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.default.send_redirects=0" >> /etc/sysctl.d/tcp_hardening.conf
      fi

      # Ignore ICMP requests.
      read -r -p "Ignore ICMP requests? (y/n) " ignore_icmp
      if [ "${ignore_icmp}" = "y" ]; then
        echo "net.ipv4.icmp_echo_ignore_all=1" >> /etc/sysctl.d/tcp_hardening.conf
      fi
    fi

    # Improve ASLR for mmap.
    read -r -p "Improve ASLR effectiveness for mmap? (y/n) " improve_aslr
    if [ "${improve_aslr}" = "y" ]; then
      echo "vm.mmap_rnd_bits=32
vm.mmap_rnd_compat_bits=16" > /etc/sysctl.d/mmap_aslr.conf
    fi

    # Disable TCP timestamps
    read -r -p "Disable TCP timestamps? (y/n) " timestamps
    if [ "${timestamps}" = "y" ]; then
      echo "net.ipv4.tcp_timestamps=0" > /etc/sysctl.d/tcp_timestamps.conf
    fi

    # Disable the SysRq key.
    read -r -p "Disable the SysRq key? (y/n) " disable_sysrq
    if [ "${disable_sysrq}" = "y" ]; then
      echo "kernel.sysrq=0" > /etc/sysctl.d/sysrq.conf
    fi

    # Disable unprivileged user namespaces.
    read -r -p "Disable unprivileged user namespaces? (y/n) " disable_unprivileged_userns
    if [ "${disable_unprivileged_userns}" = "y" ]; then
      echo "kernel.unprivileged_userns_clone=0" > /etc/sysctl.d/unprivileged_users_clone.conf
    fi

    # Disable TCP SACK.
    read -r -p "Disable TCP SACK? (y/n) " disable_sack
    if [ "${disable_sack}" = "y" ]; then
      echo "net.ipv4.tcp_sack=0" > /etc/sysctl.d/tcp_sack.conf
    fi
  fi
}

boot_parameter_hardening() {
  ## Boot Parameters.
  read -r -p "Harden the kernel through boot parameters? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#boot_parameters) (y/n) " bootparams
  if [ "${bootparams}" = "y" ]; then
    # GRUB-specific configuration.
    if [ "${use_grub}" = "y" ]; then
      # Add kernel hardening boot parameters.
      # shellcheck disable=SC2016
      echo '''GRUB_CMDLINE_LINUX="$GRUB_CMDLINE_LINUX slab_nomerge slub_debug=FZP mce=0 page_poison=1 pti=on mds=full,nosmt"''' > /etc/default/grub.d/40_kernel_hardening.cfg
    elif [ "${use_syslinux}" = "y" ]; then
      # Append new boot parameters.
      syslinux_append "slab_nomerge slub_debug=FZP mce=0 page_poison=1 pti=on mds=full,nosmt module.sig_enforce=1"
    fi

    # Require kernel modules to be signed with a valid key.
    # This prevents out-of-tree modules from being loaded so it's separate from the bulk of the hardening parameters.
    read -r -p "Require kernel modules to be signed with a valid key? (y/n) " require_signed_modules
    if [ "${require_signed_modules}" = "y" ]; then
      # GRUB-specific configuration.
      if [ "${use_grub}" = "y" ]; then
        # Add kernel hardening boot parameters.
        # shellcheck disable=SC2016
        echo '''GRUB_CMDLINE_LINUX="$GRUB_CMDLINE_LINUX module.sig_enforce=1"''' > /etc/default/grub.d/40_require_signed_modules.cfg
      elif [ "${use_syslinux}" = "y" ]; then
        # Append new boot parameters.
        syslinux_append "module.sig_enforce=1"
      fi
    fi

    # Disable IPv6.
    read -r -p "Do you want to disable IPv6? (y/n) " disable_ipv6
    if [ "${disable_ipv6}" = "y" ]; then
      if [ "${use_grub}" = "y" ]; then
        # shellcheck disable=SC2016
        echo '''GRUB_CMDLINE_LINUX="$GRUB_CMDLINE_LINUX ipv6.disable=1"''' > /etc/default/grub.d/40_disable_ipv6.cfg
      elif [ "${use_syslinux}" = "y" ]; then
        syslinux_append "ipv6.disable=1"
      fi
    fi

    if [ "${use_grub}" = "y" ]; then
      # Regenerate GRUB configuration file.
      grub-mkconfig -o /boot/grub/grub.cfg
    fi
  fi
}

hidepid() {
  ## Hidepid.
  read -r -p "Use hidepid to hide other users' processes? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#hidepid) (y/n) " hidepid
  if [ "${hidepid}" = "y" ]; then
    # Enable hidepid.
    echo "proc /proc proc nosuid,nodev,noexec,hidepid=2,gid=proc 0 0" >> /etc/fstab

    # Create proc group if it doesn't exist already.
    if ! grep "proc" /etc/group &>/dev/null; then
      groupadd proc
    fi

    # Create drop-in directory for systemd-logind if it doesn't already exist.
    if ! [ -d "/etc/systemd/system/systemd-logind.service.d/" ]; then
      mkdir /etc/systemd/system/systemd-logind.service.d/
    fi

    # Create exception for systemd-logind so user sessions still work.
    echo "[Service]
SupplementaryGroups=proc" > /etc/systemd/system/systemd-logind.service.d/hidepid.conf
  fi
}

disable_nf_conntrack_helper() {
  ## Disable Netfilter connection tracking helper.
  read -r -p "Disable the Netfilter automatic conntrack helper assignment? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#nf_conntrack_helper) (y/n) " disable_conntrack_helper
  if [ "${disable_conntrack_helper}" = "y" ]; then
    echo "options nf_conntrack nf_conntrack_helper=0" > /etc/modprobe.d/no-conntrack-helper.conf
  fi
}

install_linux_hardened() {
  ## Linux-Hardened
  read -r -p "Install linux-hardened? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#linux-hardened) (y/n) " linux_hardened
  if [ "${linux_hardened}" = "y" ]; then
    # Install linux-hardened.
    pacman -S --noconfirm -q linux-hardened linux-hardened-headers

    # Re-generate GRUB configuration.
    grub-mkconfig -o /boot/grub/grub.cfg
  fi
}

apparmor() {
  ## Apparmor
  read -r -p "Enable apparmor? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#MAC) (y/n) " enable_apparmor
  if [ "${enable_apparmor}" = "y" ]; then
    # Check if apparmor is installed and if not, install it
    if ! pacman -Qq apparmor &>/dev/null; then
      pacman -S --noconfirm -q apparmor
    fi

    # Enable AppArmor systemd service.
    systemctl enable apparmor.service

    # Enable AppArmor with a boot parameter.
    if [ "${use_grub}" = "y" ]; then
      # shellcheck disable=SC2016
      echo '''GRUB_CMDLINE_LINUX="$GRUB_CMDLINE_LINUX apparmor=1 security=apparmor audit=1"''' > /etc/default/grub.d/40_enable_apparmor.cfg

      # Re-generate GRUB configuration.
      grub-mkconfig -o /boot/grub/grub.cfg
    elif [ "${use_syslinux}" = "y" ]; then
      syslinux_append "apparmor=1 security=apparmor audit=1"
    fi
  fi
}

get_firejail() {
  ## Firejail
  read -r -p "Install firejail? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#sandboxes) (y/n) " install_firejail
  if [ "${install_firejail}" = "y" ]; then
    # Installs firejail if it isn't already.
    if ! pacman -Qq firejail &>/dev/null; then
      pacman -S --noconfirm -q firejail
    fi
  fi
}

restrict_root() {
  ## Restricting root
  # Clear /etc/securetty
  read -r -p "Clear /etc/securetty? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#securetty) (y/n) " securetty
  if [ "${securetty}" = "y" ]; then
    echo "" > /etc/securetty
  fi

  # Restricting su to users in the wheel group.
  read -r -p "Restrict su to users in the wheel group? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#restricting_su) (y/n) " restrict_su
  if [ "${restrict_su}" = "y" ]; then
    # Restricts su by editing files in /etc/pam.d/
    sed -i 's/#auth		required	pam_wheel.so use_uid/auth		required	pam_wheel.so use_uid/' /etc/pam.d/su
    sed -i 's/#auth		required	pam_wheel.so use_uid/auth		required	pam_wheel.so use_uid/' /etc/pam.d/su-l
  fi

  # Lock the root account.
  read -r -p "Lock the root account? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#locking_root) (y/n) " lock_root_account
  if [ "${lock_root_account}" = "y" ]; then
    passwd -l root
  fi

  # Checks if SSH is installed before asking.
  if [ -x "$(command -v ssh)" ]; then
    # Deny root login via SSH.
    read -r -p "Deny root login via SSH? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#denying_root_login_ssh) (y/n) " deny_root_ssh
    if [ "${deny_root_ssh}" = "y" ]; then
      echo 'PermitRootLogin no' >> /etc/ssh/sshd_config
    fi
  fi
}

firewall() {
  ## Firewall
  read -r -p "Install and configure UFW? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#firewalls) (y/n) " install_ufw
  if [ "${install_ufw}" = "y" ]; then
    # Installs ufw if it isn't already.
    if ! pacman -Qq ufw &>/dev/null; then
      pacman -S --noconfirm -q ufw
    fi

    # Enable UFW.
    ufw enable
    systemctl enable ufw.service

    # Deny all incoming traffic.
    ufw default deny incoming # Also disables ICMP timestamps
  fi
}

setup_tor() {
  ## Tor.
  read -r -p "Do you want to install Tor? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#tor) (y/n) " install_tor
  if [ "${install_tor}" = "y" ]; then
    # Installs Tor if it isn't already.
    if ! pacman -Qq tor &>/dev/null; then
      pacman -S --noconfirm -q tor
    fi

    # Force Pacman through Tor
    read -r -p "Force pacman through Tor? (See: https://theprivacyguide1.github.io/linux_hardening_guide.html#stream_isolation) (y/n) " pacman_tor
    if [ "${pacman_tor}" = "y" ]; then
      # Configure a SocksPort for Pacman.
      echo '''
# Pacman SocksPort
SocksPort 9062''' >> /etc/tor/torrc
      sed -i 's/#XferCommand = \/usr\/bin\/curl -L -C - -f -o %o %u/XferCommand = \/usr\/bin\/curl --socks5-hostname localhost:9062 --continue-at - --fail --output %o %u/' /etc/pacman.conf

      # Only use https mirrors incase of compromised exit nodes.
      sed -i 's/Server = http:/#Server = http:/' /etc/pacman.d/mirrorlist
    fi

    # Enables tor systemd service.
    systemctl enable --now tor.service
  fi
}

configure_hostname() {
  ## Change hostname to a generic one.
  read -r -p "Change hostname to 'host'? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#hostnames) (y/n) " hostname
  if [ "${hostname}" = "y" ]; then
    hostnamectl set-hostname host
  fi
}

block_wireless_devices() {
  ## Wireless devices
  read -r -p "Block all wireless devices with rfkill? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#bluetooth) (y/n) " block_wireless
  if [ "${block_wireless}" = "y" ]; then
    # Uses rfkill to block all wireless devices.
    rfkill block all

    # Unblock WiFi.
    read -r -p "Unblock WiFi? (y/n) " unblock_wifi
    if [ "${unblock_wifi}" = "y" ]; then
      rfkill unblock wifi
    fi

    # Blacklist bluetooth kernel module.
    read -r -p "Blacklist the bluetooth kernel module? (y/n) " blacklist_bluetooth
    if [ "${blacklist_bluetooth}" = "y" ]; then
      echo "install btusb /bin/true
install bluetooth /bin/true" > /etc/modprobe.d/blacklist-bluetooth.conf
    fi
  fi
}

mac_address_spoofing() {
  ## MAC Address Spoofing.
  read -r -p "Spoof MAC address automatically at boot? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#mac_address) (y/n) " spoof_mac_address
  if [ "${spoof_mac_address}" = "y" ]; then
    read -r -p "Use macchanger or NetworkManager? " which_mac_spoofer
    if [ "${which_mac_spoofer}" = "macchanger" ]; then
      # Installs macchanger if it isn't already.
      if ! pacman -Qq macchanger &>/dev/null; then
        pacman -S --noconfirm -q macchanger
      fi

      # Get mac spoofing script.
      mkdir -m 755 /usr/lib/arch-hardening-script
      curl -s --tlsv1.2 --proto =https https://gitlab.com/madaidan/arch-hardening-script/raw/master/spoof-mac-addresses.sh > /usr/lib/arch-hardening-script/spoof-mac-addresses

      # Set permissions.
      chown root -R /usr/lib/arch-hardening-script
      chmod 744 /usr/lib/arch-hardening-script/spoof-mac-addresses

      # Creates systemd service for MAC spoofing.
      cat <<EOF > /etc/systemd/system/macspoof.service
[Unit]
Description=Spoofs MAC addresses
Wants=network-pre.target
Before=network-pre.target

[Service]
ExecStart=/usr/lib/arch-hardening-script/spoof-mac-addresses
Type=oneshot
CapabilityBoundingSet=CAP_NET_ADMIN
ProtectSystem=strict
ProtectHome=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
PrivateTmp=true
MemoryDenyWriteExecute=true
NoNewPrivileges=true
RestrictRealtime=true
RestrictAddressFamilies=AF_INET
SystemCallArchitectures=native
RestrictNamespaces=true

[Install]
WantedBy=multi-user.target
EOF

      # Enables systemd service.
      systemctl enable macspoof.service
    elif [ "${which_mac_spoofer}" = "NetworkManager" ]; then
        # Installs networkmanager if it isn't already installed.
        if ! pacman -Qq networkmanager &>/dev/null; then
          read -r -p "NetworkManager is not installed. Install it now? (y/n) " install_networkmanager
          if [ "${install_networkmanager}" = "y" ]; then
            pacman -S --noconfirm -q networkmanager
          fi
        fi

        # Randomize MAC address with networkmanager.
        cat <<EOF > /etc/NetworkManager/conf.d/rand_mac.conf
[connection-mac-randomization]
ethernet.cloned-mac-address=random
wifi.cloned-mac-address=random
EOF
    fi
  fi
}

configure_umask() {
  ## Set a more restrictive umask.
  read -r -p "Set a more restrictive umask? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#umask) (y/n) " umask
  if [ "${umask}" = "y" ]; then
    echo "umask 0077" > /etc/profile.d/umask.sh
  fi
}

install_usbguard() {
  ## USBGuard.
  read -r -p "Install USBGuard? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#usbs) (y/n) " usbguard
  if [ "${usbguard}" = "y" ]; then
    # Checks if usbguard is already installed.
    if ! pacman -Qq usbguard &>/dev/null; then
      # Installs usbguard.
      pacman -S --noconfirm -q usbguard
    fi
  fi
}

blacklist_dma() {
  ## Blacklist thunderbolt and firewire kernel modules.
  read -r -p "Blacklist Thunderbolt and Firewire? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#thunderbolt_and_firewire) (y/n) " thunderbolt_firewire
  if [ "${thunderbolt_firewire}" = "y" ]; then
    echo "install firewire-core /bin/true
install thunderbolt /bin/true" > /etc/modprobe.d/blacklist-dma.conf
  fi
}

disable_coredumps() {
  ## Core Dumps
  read -r -p "Disable coredumps? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#core_dumps) (y/n) " coredumps
  if [ "${coredumps}" = "y" ]; then
    # Disables coredumps via sysctl.
    echo "kernel.core_pattern=|/bin/false" > /etc/sysctl.d/disable_coredumps.conf

    # Make coredump drop-in directory if it doesn't already exist.
    if ! [ -d /etc/systemd/coredump.conf.d ]; then
      mkdir /etc/systemd/coredump.conf.d
    fi

    # Disables coredumps via systemd.
    echo "[Coredump]
Storage=none" > /etc/systemd/coredump.conf.d/disable_coredumps.conf

    # Disables coredumps via limits.
    echo "* hard core 0" >> /etc/security/limits.conf

    # Prevents SUID processes from creating coredumps if not already set.
    if ! sysctl fs.suid_dumpable | grep "0" &>/dev/null; then
      echo "fs.suid_dumpable=0" > /etc/sysctl.d/suid_dumpable.conf
    fi
  fi
}

microcode_updates() {
  ## Microcode updates.
  read -r -p "Install microcode updates? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#microcode) (y/n) " microcode
  if [ "${microcode}" = "y" ]; then
    # Checks which CPU is being used.
    if grep 'AMD' /proc/cpuinfo >/dev/null; then
      # Install AMD ucode.
      if ! pacman -Qq amd-ucode &>/dev/null; then
        pacman -S --noconfirm -q amd-ucode
      fi

      cpu_manufacturer="amd"
    elif grep 'Intel' /proc/cpuinfo >/dev/null; then
      # Install Intel ucode.
      if ! pacman -Qq intel-ucode &>/dev/null; then
        pacman -S --noconfirm -q intel-ucode
      fi

      cpu_manufacturer="intel"
    fi

    if [ "${use_grub}" = "y" ]; then
      # Update GRUB configuration.
      grub-mkconfig -o /boot/grub/grub.cfg
    elif [ "${use_syslinux}" = "y" ]; then
      # Get current initrd configuration.
      current_initrd=$(grep -v "Fallback" /boot/syslinux/syslinux.cfg | grep -C 3 "MENU LABEL Arch Linux" | grep "INITRD")

      # Update syslinux configuration.
      sed -i "s|${current_initrd}|${current_initrd},../${cpu_manufacturer}-ucode.img|" /boot/syslinux/syslinux.cfg
    fi
  fi
}

disable_ntp() {
  ## NTP
  read -r -p "Disable NTP? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#ntp) (y/n) " ntp
  if [ "${ntp}" = "y" ]; then
    # Uninstalls NTP clients
    for ntp_client in ntp openntpd ntpclient
    do
      if pacman -Qq "${ntp_client}" &>/dev/null; then
        pacman -Rn --noconfirm ${ntp_client}
      fi
    done

    # Disables NTP
    timedatectl set-ntp 0
    systemctl mask systemd-timesyncd.service
  fi
}

ipv6_privacy_extensions() {
  ## IPv6 Privacy Extensions
  if ! [ "${disable_ipv6}" = "y" ]; then
    read -r -p "Do you want to enable IPv6 privacy extensions? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#ipv6_privacy) (y/n) " ipv6_privacy
    if [ "${ipv6_privacy}" = "y" ]; then
      # Enable IPv6 privacy extensions via sysctl.
      echo "net.ipv6.conf.all.use_tempaddr=2
net.ipv6.conf.default.use_tempaddr=2" > /etc/sysctl.d/ipv6_privacy.conf

      # Get list of network interfaces. Excludes loopback and virtual machine interfaces.
      net_interfaces=$(ls /sys/class/net | grep -v 'lo' | grep -v 'tun0' | grep -v "virbr")

      # Add them to ipv6_privacy.conf.
      for i in ${net_interfaces}
      do
        echo "net.ipv6.conf.${i}.use_tempaddr=2" >> /etc/sysctl.d/ipv6_privacy.conf
      done

      ## Check for NetworkManager.
      if pacman -Qq networkmanager &>/dev/null; then
        # Enable IPv6 privacy extensions for NetworkManager.
        read -r -p "Enable IPv6 privacy extensions for NetworkManager? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#ipv6_networkmanager) (y/n)" networkmanager
        if [ "${networkmanager}" = "y" ]; then
          echo "[connection]
ipv6.ip6-privacy=2" >> /etc/NetworkManager/NetworkManager.conf
        fi
      fi

      ## Check for systemd-networkd.
      if systemctl is-active systemd-networkd.service >/dev/null 2>&1; then
        # Enable IPv6 privacy extensions for systemd-networkd.
        read -r -p "Enable IPv6 privacy extensions for systemd-networkd? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#ipv6_systemd-networkd) (y/n) " systemd-networkd
        if [ "${systemd-networkd}" = "y" ]; then
          echo "[Network]
IPv6PrivacyExtensions=kernel" > /etc/systemd/network/ipv6_privacy.conf
        fi
      fi
    fi
  fi
}

blacklist_uncommon_network_protocols() {
  ## Blacklist uncommon network protocols.
  read -r -p "Blacklist uncommon network protocols? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#uncommon_protocols) (y/n) " blacklist_net_protocols
  if [ "${blacklist_net_protocols}" = "y" ]; then
    cat <<EOF > /etc/modprobe.d/uncommon-network-protocols.conf
install dccp /bin/true
install sctp /bin/true
install rds /bin/true
install tipc /bin/true
install n-hdlc /bin/true
install ax25 /bin/true
install netrom /bin/true
install x25 /bin/true
install rose /bin/true
install decnet /bin/true
install econet /bin/true
install af_802154 /bin/true
install ipx /bin/true
install appletalk /bin/true
install psnap /bin/true
install p8023 /bin/true
install llc /bin/true
install p8022 /bin/true
EOF
  fi
}

disable_uncommon_filesystems() {
  ## Disable mounting of uncommon filesystems.
  read -r -p "Disable mounting of uncommon filesystems? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#uncommon_filesystems) (y/n) " blacklist_filesystems
  if [ "${blacklist_filesystems}" = "y" ]; then
    cat <<EOF > /etc/modprobe.d/uncommon-filesystems.conf
install cramfs /bin/true
install freevxfs /bin/true
install jffs2 /bin/true
install hfs /bin/true
install hfsplus /bin/true
install squashfs /bin/true
install udf /bin/true
EOF
  fi
}

more_entropy() {
  ## Gather more entropy.
  read -r -p "Do you want to gather more entropy? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#entropy) (y/n) " gather_more_entropy
  if [ "${gather_more_entropy}" = "y" ]; then
    # Enable haveged.
    if ! pacman -Qq haveged &>/dev/null; then
      read -r -p "Do you want to install and enable haveged? (y/n) " enable_haveged
      if [ "${enable_haveged}" = "y" ]; then
        pacman -S --noconfirm -q haveged
        systemctl enable haveged.service
      fi
    fi

    # Install jitterentropy.
    if ! pacman -Qq jitterentropy &>/dev/null; then
      read -r -p "Do you want to install jitterentropy? (y/n) " install_jitterentropy
      if [ "${install_jitterentropy}" = "y" ]; then
        pacman -S --noconfirm -q jitterentropy
      fi
    fi
  fi
}

webcam_and_microphone() {
  ## Block the webcam and microphone.
  read -r -p "Do you want to blacklist the webcam kernel module? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#microphones_and_webcams) (y/n) " blacklist_webcam
  if [ "${blacklist_webcam}" = "y" ]; then
    # Blacklist the webcam kernel module.
    echo "install uvcvideo /bin/true" > /etc/modprobe.d/blacklist-webcam.conf
  fi

  read -r -p "Do you want to blacklist the microphone and speaker kernel module? (see: https://theprivacyguide1.github.io/linux_hardening_guide.html#microphones_and_webcams) (y/n) " blacklist_mic
  if [ "${blacklist_mic}" = "y" ]; then
    # Blacklist the microphone and speaker kernel module.
    mic_modules=$(awk '{print $2}' /proc/asound/modules | awk '!x[$0]++')

    # Accounts for multiple sound cards.
    for i in ${mic_modules}
    do
      echo "install ${i} /bin/true" >> /etc/modprobe.d/blacklist-mic.conf
    done
  fi
}

ending() {
  ## Reboot
  read -r -p "Reboot to apply all of the changes? (y/n) " reboot
  if [ "${reboot}" = "y" ]; then
    reboot
  fi
}

read -r -p "See this page for further details on many of these options: 
https://theprivacyguide1.github.io/linux_hardening_guide
Start? (y/n) " start
if [ "${start}" = "n" ]; then
  exit 1
elif ! [ "${start}" = "y" ]; then
  echo "You did not enter a correct character."
  exit 1
fi

script_checks
sysctl_hardening
boot_parameter_hardening
hidepid
disable_nf_conntrack_helper
install_linux_hardened
apparmor
get_firejail
restrict_root
firewall
setup_tor
configure_hostname
block_wireless_devices
mac_address_spoofing
configure_umask
install_usbguard
blacklist_dma
disable_coredumps
microcode_updates
disable_ntp
ipv6_privacy_extensions
blacklist_uncommon_network_protocols
disable_uncommon_filesystems
more_entropy
webcam_and_microphone
ending

exit;
;;
  4) echo "Exiting..\n";;

  *) echo "invalid option";;
esac
